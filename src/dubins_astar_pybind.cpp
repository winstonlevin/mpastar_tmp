#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/operators.h>

#include "dubins_astar.h"

namespace py = pybind11;

void init_dubins_astar(py::module_ m) {
    py::class_<DangerZone>(m, "DangerZone")
        .def(py::init())
        .def(py::init<Position, double, double>())
        .def_readwrite("pc", &DangerZone::pc)
        .def_readwrite("rc", &DangerZone::rc)
        .def_readwrite("rc2", &DangerZone::rc2)
        .def_readwrite("cost_gain", &DangerZone::cost_gain)
        .def("__repr__", &DangerZone::to_string)
        .def("cost", &DangerZone::cost)
        ;

    py::class_<Connection>(m, "Connection")
        .def(py::init())
        .def(py::init<float, bool, bool, bool>())
        .def_readwrite("cost", &Connection::cost)
        .def_readwrite("left0", &Connection::left0)
        .def_readwrite("csc", &Connection::csc)
        .def_readwrite("leftf", &Connection::leftf)
        .def("__repr__", &Connection::to_string)
        ;

    py::class_<SampledNFAstar>(m, "SampledNFAstar")
        .def(py::init())
        .def(py::init<State, Position>())
        .def(py::init<State, Position, std::vector<Circle>>())
        .def(py::init<State, Position, std::vector<Circle>, std::vector<Polygon>>())
        .def(py::init<State, Position, std::vector<Circle>, double, double>())
        .def(py::init<State, Position, std::vector<Circle>, std::vector<Polygon>, double, double>())
        .def(py::init<State, Position, std::vector<Circle>, int>())
        .def(py::init<State, Position, std::vector<Circle>, std::vector<Polygon>, int>())
        .def(py::init<State, Position, std::vector<Circle>, double, double, int>())
        .def(py::init<State, Position, std::vector<Circle>, std::vector<Polygon>, double, double, int>())
        .def_readwrite("x0", &SampledNFAstar::x0)
        .def_readwrite("pf", &SampledNFAstar::pf)
        .def_readwrite("nf", &SampledNFAstar::nf)
        .def_readwrite("poly", &SampledNFAstar::poly)
        .def_readwrite("v", &SampledNFAstar::v)
        .def_readwrite("mu_max", &SampledNFAstar::mu_max)
        .def_readwrite("tol", &SampledNFAstar::tol)
        .def_readwrite("n_samples", &SampledNFAstar::n_samples)
        .def_readwrite("psi_samples", &SampledNFAstar::psi_samples)
        .def_readwrite("nodes", &SampledNFAstar::nodes)
        .def_readwrite("dpsi", &SampledNFAstar::dpsi)
        .def_readwrite("turns", &SampledNFAstar::turns)
        .def("__repr__", &SampledNFAstar::to_string)
        .def("connect_edge", &SampledNFAstar::connect_edge, "Calculate edge cost from one Node to another (INF if no feasible connection)")
        .def("straight_collision", &SampledNFAstar::straight_collision, "Check if straight arc intersects a no-fly zone")
        .def("turn_collision", &SampledNFAstar::turn_collision, "Check if turn arc intersects a no-fly zone")
        .def("initialize_nodes", &SampledNFAstar::initialize_nodes, "Convert input data into nodes")
        .def("sample_boundary", &SampledNFAstar::sample_boundary)
        .def("solve_astar", &SampledNFAstar::solve_astar, "Apply astar algorithm to graph")
        ;

    m.def("project_monotonic_increasing", &project_monotonic_increasing, "Find index closest to given value");
    m.def("project_uniform_spacing", &project_uniform_spacing, "Find index closest to given value");

    py::class_<DenseTreeNFAstarNodeAux>(m, "DenseTreeNFAstarNodeAux")
        .def(py::init())
        .def(py::init<AstarNode, unsigned short int, State>())
        .def_readwrite("n", &DenseTreeNFAstarNodeAux::n)
        .def_readwrite("psi_idx", &DenseTreeNFAstarNodeAux::psi_idx)
        .def_readwrite("x", &DenseTreeNFAstarNodeAux::x)
        .def("__repr__", &DenseTreeNFAstarNodeAux::to_string)
        ;

    py::class_<Initializable<bool>>(m, "InitializableBool")
        .def(py::init())
        .def(py::init<bool>())
        .def_readwrite("value", &Initializable<bool>::value)
        .def_readwrite("init", &Initializable<bool>::init)
        .def("update", &Initializable<bool>::update)
        .def("__repr__", &Initializable<bool>::to_string)
        ;

    py::class_<Initializable<double>>(m, "InitializableDouble")
        .def(py::init())
        .def(py::init<double>())
        .def_readwrite("value", &Initializable<double>::value)
        .def_readwrite("init", &Initializable<double>::init)
        .def("update", &Initializable<double>::update)
        .def("__repr__", &Initializable<double>::to_string)
        ;

    py::class_<DenseHeuristic>(m, "DenseHeuristic")
        .def(py::init())
        .def(py::init<float>())
        .def(py::init<float, float>())
        .def(py::init<float, float, bool>())
        .def("__repr__", &DenseHeuristic::to_string)
        .def_readwrite("heuristic", &DenseHeuristic::heuristic)
        .def_readwrite("distance", &DenseHeuristic::distance)
        .def_readwrite("terminal", &DenseHeuristic::terminal)
        ;

    py::class_<DenseTreeNFAstar>(m, "DenseTreeNFAstar")
        .def(py::init())
        .def(py::init<State, Position>())
        .def(py::init<State, Position, std::vector<Circle>>())
        .def(py::init<State, Position, std::vector<Circle>, double, double>())
        .def(py::init<State, Position, std::vector<Circle>, int>())
        .def(py::init<State, Position, std::vector<Circle>, double, double, int>())
        .def_readwrite("x0", &DenseTreeNFAstar::x0)
        .def_readwrite("pf", &DenseTreeNFAstar::pf)
        .def_readwrite("nf", &DenseTreeNFAstar::nf)
        .def_readwrite("v", &DenseTreeNFAstar::v)
        .def_readwrite("mu_max", &DenseTreeNFAstar::mu_max)
        .def_readwrite("tol", &DenseTreeNFAstar::tol)
        .def_readwrite("x_min", &DenseTreeNFAstar::x_min)
        .def_readwrite("x_max", &DenseTreeNFAstar::x_max)
        .def_readwrite("y_min", &DenseTreeNFAstar::y_min)
        .def_readwrite("y_max", &DenseTreeNFAstar::y_max)
        .def_readwrite("dpsi", &DenseTreeNFAstar::dpsi)
        .def_readwrite("dp", &DenseTreeNFAstar::dp)
        .def_readwrite("dpf_tol", &DenseTreeNFAstar::dpf_tol)
        .def_readwrite("n_psi_samples", &DenseTreeNFAstar::n_psi_samples)
        .def_readwrite("n_x_samples", &DenseTreeNFAstar::n_x_samples)
        .def_readwrite("n_y_samples", &DenseTreeNFAstar::n_y_samples)
        .def_readwrite("x0_idx", &DenseTreeNFAstar::x0_idx)
        .def_readwrite("y0_idx", &DenseTreeNFAstar::y0_idx)
        .def_readwrite("psi0_idx", &DenseTreeNFAstar::psi0_idx)
        .def_readwrite("xf_idx", &DenseTreeNFAstar::xf_idx)
        .def_readwrite("yf_idx", &DenseTreeNFAstar::yf_idx)
        .def_readwrite("next_node_id", &DenseTreeNFAstar::next_node_id)
        .def_readwrite("x_samples", &DenseTreeNFAstar::x_samples)
        .def_readwrite("y_samples", &DenseTreeNFAstar::y_samples)
        .def_readwrite("psi_samples", &DenseTreeNFAstar::psi_samples)
        .def_readwrite("cos_samples", &DenseTreeNFAstar::cos_samples)
        .def_readwrite("sin_samples", &DenseTreeNFAstar::sin_samples)
        .def_readwrite("nodes", &DenseTreeNFAstar::nodes)
        .def_readwrite("collisions", &DenseTreeNFAstar::collisions)
        .def("__repr__", &DenseTreeNFAstar::to_string)
        .def("check_collision", &DenseTreeNFAstar::check_collision, "Return true if x_idx/y_idx collide with no-fly zone")
        .def("heuristic_fun", &DenseTreeNFAstar::heuristic_fun, "Heuristic (lower bound on cost-to-go)")
        .def("initialize_nodes", &DenseTreeNFAstar::initialize_nodes, "Convert input data into initial node")
        .def("add_successor", &DenseTreeNFAstar::add_successor, "Add a successor")
        .def("successor_function", &DenseTreeNFAstar::successor_function, "Find and add successors to node")
        .def("solve_astar", &DenseTreeNFAstar::solve_astar, "Apply astar algorithm to graph")
        ;

    py::class_<RationalAngle>(m, "RationalAngle")
        .def(py::init())
        .def(py::init<short int, short int, short int>())
        .def(py::init<short int, short int, short int, double>())
        .def_readwrite("dsina", &RationalAngle::dsina)
        .def_readwrite("dcosa", &RationalAngle::dcosa)
        .def_readwrite("fac", &RationalAngle::fac)
        .def_readwrite("a", &RationalAngle::a)
        .def_readwrite("within_tol", &RationalAngle::within_tol)
        .def("__repr__", &RationalAngle::to_string)
        ;

    py::class_<DenseNFAstarNodeAux>(m, "DenseNFAstarNodeAux")
        .def(py::init())
        .def(py::init<AstarNode, unsigned short int, unsigned short int, unsigned short int>())
        .def_readwrite("n", &DenseNFAstarNodeAux::n)
        .def_readwrite("x_idx", &DenseNFAstarNodeAux::x_idx)
        .def_readwrite("y_idx", &DenseNFAstarNodeAux::y_idx)
        .def_readwrite("psi_idx", &DenseNFAstarNodeAux::psi_idx)
        .def("__repr__", &DenseNFAstarNodeAux::to_string)
        ;

    py::class_<Transition>(m, "Transition")
        .def(py::init())
        .def(py::init<unsigned short int, float>())
        .def_readwrite("dxy_idx", &Transition::dxy_idx)
        .def_readwrite("psi_idx", &Transition::psi_idx)
        .def_readwrite("arc_length", &Transition::arc_length)
        .def_readwrite("edge_cost", &Transition::edge_cost)
        .def("__repr__", &Transition::to_string)
        ;

    m.def("generate_successor_template", &generate_successor_template, "Generate successor template for dense NF A*");

    py::class_<DenseNFAstar>(m, "DenseNFAstar")
        .def(py::init())
        .def(py::init<State, Position>())
        .def(py::init<State, Position, unsigned short int, unsigned short int>())
        .def(py::init<State, Position, std::vector<Circle>>())
        .def(py::init<State, Position, std::vector<Circle>, std::vector<DangerZone>>())
        .def(py::init<State, Position, std::vector<Circle>, std::vector<DangerZone>, std::vector<Polygon>>())
        .def(py::init<State, Position, double, double>())
        .def(py::init<State, Position, double, double, unsigned short int, unsigned short int>())
        .def(py::init<State, Position, std::vector<Circle>, double, double>())
        .def(py::init<State, Position, std::vector<Circle>, std::vector<DangerZone>, double, double>())
        .def(py::init<State, Position, std::vector<Circle>, std::vector<DangerZone>, std::vector<Polygon>, double, double>())
        .def(py::init<State, Position, std::vector<Circle>, unsigned short int, unsigned short int>())
        .def(py::init<State, Position, std::vector<Circle>, std::vector<DangerZone>, unsigned short int, unsigned short int>())
        .def(py::init<State, Position, std::vector<Circle>, std::vector<DangerZone>, std::vector<Polygon>, unsigned short int, unsigned short int>())
        .def(py::init<State, Position, std::vector<Circle>, double, double, unsigned short int, unsigned short int>())
        .def(py::init<State, Position, std::vector<Circle>, std::vector<DangerZone>, double, double, unsigned short int, unsigned short int>())
        .def(py::init<State, Position, std::vector<Circle>, std::vector<DangerZone>, std::vector<Polygon>, double, double, unsigned short int, unsigned short int>())
        .def_readwrite("x0", &DenseNFAstar::x0)
        .def_readwrite("pf", &DenseNFAstar::pf)
        .def_readwrite("nf", &DenseNFAstar::nf)
        .def_readwrite("dz", &DenseNFAstar::dz)
        .def_readwrite("poly", &DenseNFAstar::poly)
        .def_readwrite("control_cost_gain", &DenseNFAstar::control_cost_gain)
        .def_readwrite("v", &DenseNFAstar::v)
        .def_readwrite("mu_max", &DenseNFAstar::mu_max)
        .def_readwrite("tol", &DenseNFAstar::tol)
        .def_readwrite("x_min", &DenseNFAstar::x_min)
        .def_readwrite("x_max", &DenseNFAstar::x_max)
        .def_readwrite("y_min", &DenseNFAstar::y_min)
        .def_readwrite("y_max", &DenseNFAstar::y_max)
        .def_readwrite("psi_fidelity", &DenseNFAstar::psi_fidelity)
        .def_readwrite("dp_fidelity", &DenseNFAstar::dp_fidelity)
        .def_readwrite("radius", &DenseNFAstar::radius)
        .def_readwrite("dpf_tol", &DenseNFAstar::dpf_tol)
        .def_readwrite("n_psi_samples", &DenseNFAstar::n_psi_samples)
        .def_readwrite("n_x_samples", &DenseNFAstar::n_x_samples)
        .def_readwrite("n_y_samples", &DenseNFAstar::n_y_samples)
        .def_readwrite("x0_idx", &DenseNFAstar::x0_idx)
        .def_readwrite("y0_idx", &DenseNFAstar::y0_idx)
        .def_readwrite("psi0_idx", &DenseNFAstar::psi0_idx)
        .def_readwrite("xf_idx", &DenseNFAstar::xf_idx)
        .def_readwrite("yf_idx", &DenseNFAstar::yf_idx)
        .def_readwrite("x_samples", &DenseNFAstar::x_samples)
        .def_readwrite("y_samples", &DenseNFAstar::y_samples)
        .def_readwrite("psir_samples", &DenseNFAstar::psir_samples)
        .def_readwrite("rat_trig", &DenseNFAstar::rat_trig)
        .def_readwrite("successor_template", &DenseNFAstar::successor_template)
        .def_readwrite("nodes", &DenseNFAstar::nodes)
        .def_readwrite("collisions", &DenseNFAstar::collisions)
        .def("__repr__", &DenseNFAstar::to_string)
        .def("idces2id", &DenseNFAstar::idces2id, "Convert x_idx, y_idx, psi_idx to id")
        .def("check_collision", &DenseNFAstar::check_collision, "Return true if x_idx/y_idx collide with no-fly zone")
        .def("heuristic_fun", &DenseNFAstar::heuristic_fun, "Heuristic (lower bound on cost-to-go)")
        .def("initialize_nodes", &DenseNFAstar::initialize_nodes, "Convert input data into initial node")
        .def("successor_function", &DenseNFAstar::successor_function, "Find and add successors to node")
        .def("solve_astar", &DenseNFAstar::solve_astar, "Apply astar algorithm to graph")
        .def("construct_path", &DenseNFAstar::construct_path, "Generate vector of node aux from goal to start")
        ;
}  // init_dubins_astar